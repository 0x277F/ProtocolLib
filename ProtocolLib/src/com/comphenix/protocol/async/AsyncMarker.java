package com.comphenix.protocol.async;

import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.List;

import net.minecraft.server.Packet;

import com.comphenix.protocol.PacketStream;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.injector.PrioritizedListener;
import com.comphenix.protocol.reflect.FieldAccessException;
import com.comphenix.protocol.reflect.FuzzyReflection;
import com.google.common.primitives.Longs;

/**
 * Contains information about the packet that is being processed by asynchronous listeners.
 * <p>
 * Asynchronous listeners can use this to set packet timeout or transmission order.
 * 
 * @author Kristian
 */
public class AsyncMarker implements Serializable, Comparable<AsyncMarker> {
		
	/**
	 * Generated by Eclipse.
	 */
	private static final long serialVersionUID = -2621498096616187384L;

	/**
	 * Default number of milliseconds until a packet will rejected.
	 */
	public static final int DEFAULT_TIMEOUT_DELTA = 60000;
	
	/**
	 * Default number of packets to skip.
	 */
	public static final int DEFAULT_SENDING_DELTA = 0;
	
	/**
	 * The packet stream responsible for transmitting the packet when it's done processing.
	 */
	private transient PacketStream packetStream;
	
	/**
	 * Current list of async packet listeners.
	 */
	private transient Iterator<PrioritizedListener<AsyncListenerHandler>> listenerTraversal;
	
	// Timeout handling
	private long initialTime;
	private long timeout;
	
	// Packet order
	private long originalSendingIndex;
	private long newSendingIndex;
	
	// Whether or not the packet has been processed by the listeners
	private volatile boolean processed;
	
	// Whether or not the packet has been sent
	private volatile boolean transmitted;
	
	// Whether or not the asynchronous processing itself should be cancelled
	private volatile boolean asyncCancelled;
	
	// Determine if Minecraft processes this packet asynchronously
	private static Method isMinecraftAsync;
	private static boolean alwaysSync;

	/**
	 * Create a container for asyncronous packets.
	 * @param initialTime - the current time in milliseconds since 01.01.1970 00:00.
	 */
	AsyncMarker(PacketStream packetStream, long sendingIndex, long sendingDelta, long initialTime, long timeoutDelta) {
		if (packetStream == null)
			throw new IllegalArgumentException("packetStream cannot be NULL");
		
		this.packetStream = packetStream;
		
		// Timeout
		this.initialTime = initialTime;
		this.timeout = initialTime + timeoutDelta;
		
		// Sending index
		this.originalSendingIndex = sendingIndex;
		this.newSendingIndex = sendingIndex;
	}
	
	/**
	 * Retrieve the time the packet was initially queued for asynchronous processing.
	 * @return The initial time in number of milliseconds since 01.01.1970 00:00. 
	 */
	public long getInitialTime() {
		return initialTime;
	}	

	/**
	 * Retrieve the time the packet will be forcefully rejected.
	 * @return The time to reject the packet, in milliseconds since 01.01.1970 00:00.
	 */
	public long getTimeout() {
		return timeout;
	}
	
	/**
	 * Set the time the packet will be forcefully rejected.
	 * @param timeout - time to reject the packet, in milliseconds since 01.01.1970 00:00.
	 */
	public void setTimeout(long timeout) {
		this.timeout = timeout;
	}

	/**
	 * Retrieve the order the packet was originally transmitted.
	 * @return The original packet index.
	 */
	public long getOriginalSendingIndex() {
		return originalSendingIndex;
	}

	/**
	 * Retrieve the desired sending order after processing has completed.
	 * <p>
	 * Higher sending order means lower priority.
	 * @return Desired sending order.
	 */
	public long getNewSendingIndex() {
		return newSendingIndex;
	}

	/**
	 * Sets the desired sending order after processing has completed.
	 * <p>
	 * Higher sending order means lower priority.
	 * @param newSendingIndex - new packet send index.
	 */
	public void setNewSendingIndex(long newSendingIndex) {
		this.newSendingIndex = newSendingIndex;
	}

	/**
	 * Retrieve the packet stream responsible for transmitting this packet.
	 * @return The packet stream.
	 */
	public PacketStream getPacketStream() {
		return packetStream;
	}

	/**
	 * Sets the output packet stream responsible for transmitting this packet.
	 * @param packetStream - new output packet stream.
	 */
	public void setPacketStream(PacketStream packetStream) {
		this.packetStream = packetStream;
	}

	/**
	 * Retrieve whether or not this packet has been processed by the async listeners.
	 * @return TRUE if it has been processed, FALSE otherwise.
	 */
	public boolean isProcessed() {
		return processed;
	}

	/**
	 * Sets whether or not this packet has been processed by the async listeners.
	 * @param processed - TRUE if it has, FALSE otherwise.
	 */
	void setProcessed(boolean processed) {
		this.processed = processed;
	}

	/**
	 * Retrieve whether or not this packet has already been sent.
	 * @return TRUE if it has been sent before, FALSE otherwise.
	 */
	public boolean isTransmitted() {
		return transmitted;
	}

	/**
	 * Determine if this packet has expired.
	 * @return TRUE if it has, FALSE otherwise.
	 */
	public boolean hasExpired() {
		return hasExpired(System.currentTimeMillis());
	}
	
	/**
	 * Determine if this packet has expired given this time.
	 * @param currentTime - the current time in milliseconds since 01.01.1970 00:00.
	 * @return TRUE if it has, FALSE otherwise.
	 */
	public boolean hasExpired(long currentTime) {
		return timeout < currentTime;
	}
	
	/**
	 * Determine if the asynchronous handling should be cancelled.
	 * @return TRUE if it should, FALSE otherwise.
	 */
	public boolean isAsyncCancelled() {
		return asyncCancelled;
	}

	/**
	 * Set whether or not the asynchronous handling should be cancelled.
	 * @param asyncCancelled - TRUE to cancel it, FALSE otherwise.
	 */
	public void setAsyncCancelled(boolean asyncCancelled) {
		this.asyncCancelled = asyncCancelled;
	}
	
	/**
	 * Retrieve iterator for the next listener in line.
	 * @return Next async packet listener iterator.
	 */
	public Iterator<PrioritizedListener<AsyncListenerHandler>> getListenerTraversal() {
		return listenerTraversal;
	}
	
	/**
	 * Set the iterator for the next listener.
	 * @param listenerTraversal - the new async packet listener iterator.
	 */
	void setListenerTraversal(Iterator<PrioritizedListener<AsyncListenerHandler>> listenerTraversal) {
		this.listenerTraversal = listenerTraversal;
	}
	
	/**
	 * Transmit a given packet to the current packet stream.
	 * @param event - the packet to send.
	 * @throws IOException If the packet couldn't be sent.
	 */
	public void sendPacket(PacketEvent event) throws IOException {
		try {
			if (event.isServerPacket()) {
				packetStream.sendServerPacket(event.getPlayer(), event.getPacket(), false);
			} else {
				packetStream.recieveClientPacket(event.getPlayer(), event.getPacket(), false);
			}
			transmitted = true;
			
		} catch (InvocationTargetException e) {
			throw new IOException("Cannot send packet", e);
		} catch (IllegalAccessException e) {
			throw new IOException("Cannot send packet", e);
		}
	}
	
	/**
	 * Determine if Minecraft allows asynchronous processing of this packet.
	 * @return TRUE if it does, FALSE otherwise.
	 */
	public boolean isMinecraftAsync(PacketEvent event) throws FieldAccessException {
		
		if (isMinecraftAsync == null && !alwaysSync) {
			try {
				isMinecraftAsync = FuzzyReflection.fromClass(Packet.class).getMethodByName("a_.*");
			} catch (RuntimeException e) {
				// This will occur in 1.2.5 (or possibly in later versions)
				List<Method> methods = FuzzyReflection.fromClass(Packet.class).
										getMethodListByParameters(boolean.class, new Class[] {});
				
				// Try to look for boolean methods
				if (methods.size() == 2) {
					isMinecraftAsync = methods.get(1);
				} else if (methods.size() == 1) {
					// We're in 1.2.5
					alwaysSync = true;
				} else {
					System.err.println("Cannot determine asynchronous state of packets!");
					alwaysSync = true;
				}
			}
		}
		
		if (alwaysSync) {
			return false;
		} else {
			try {
				// Wrap exceptions 
				return (Boolean) isMinecraftAsync.invoke(event.getPacket().getHandle());
			} catch (IllegalArgumentException e) {
				throw new FieldAccessException("Illegal argument", e);
			} catch (IllegalAccessException e) {
				throw new FieldAccessException("Unable to reflect method call 'a_', or: isAsyncPacket.", e);
			} catch (InvocationTargetException e) {
				throw new FieldAccessException("Minecraft error", e);
			}
		}
	}
	
	@Override
	public int compareTo(AsyncMarker o) {
		if (o == null)
			return 1;
		else
			return Longs.compare(getNewSendingIndex(), o.getNewSendingIndex());
	}
}
