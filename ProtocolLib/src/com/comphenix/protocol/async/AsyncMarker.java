package com.comphenix.protocol.async;

import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.util.Iterator;

import com.comphenix.protocol.PacketStream;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.injector.PrioritizedListener;
import com.google.common.primitives.Longs;

/**
 * Contains information about the packet that is being processed by asynchronous listeners.
 * 
 * @author Kristian
 */
public class AsyncMarker implements Serializable, Comparable<AsyncMarker> {
		
	/**
	 * Generated by Eclipse.
	 */
	private static final long serialVersionUID = -2621498096616187384L;

	/**
	 * Default number of milliseconds until a packet will rejected.
	 */
	public static final int DEFAULT_TIMEOUT_DELTA = 60000;
	
	/**
	 * The packet stream responsible for transmitting the packet when it's done processing.
	 */
	private transient PacketStream packetStream;
	
	/**
	 * Current list of async packet listeners.
	 */
	private transient Iterator<PrioritizedListener<ListenerToken>> listenerTraversal;
	
	// Timeout handling
	private long initialTime;
	private long timeout;
	
	// Packet order
	private long originalSendingIndex;
	private long newSendingIndex;
	
	// Whether or not the packet has been processed by the listeners
	private volatile boolean processed;
	
	// Whethre or not the packet has been sent
	private volatile boolean transmitted;

	/**
	 * Create a container for asyncronous packets.
	 * @param initialTime - the current time in milliseconds since 01.01.1970 00:00.
	 */
	AsyncMarker(PacketStream packetStream, long sendingIndex, long sendingDelta, long initialTime, long timeoutDelta) {
		if (packetStream == null)
			throw new IllegalArgumentException("packetStream cannot be NULL");
		
		this.packetStream = packetStream;
		
		// Timeout
		this.initialTime = initialTime;
		this.timeout = initialTime + timeoutDelta;
		
		// Sending index
		this.originalSendingIndex = sendingIndex;
		this.newSendingIndex = sendingIndex;
	}
	
	/**
	 * Retrieve the time the packet was initially queued for asynchronous processing.
	 * @return The initial time in number of milliseconds since 01.01.1970 00:00. 
	 */
	public long getInitialTime() {
		return initialTime;
	}	

	/**
	 * Retrieve the time the packet will be forcefully rejected.
	 * @return The time to reject the packet, in milliseconds since 01.01.1970 00:00.
	 */
	public long getTimeout() {
		return timeout;
	}
	
	/**
	 * Retrieve the order the packet was originally transmitted.
	 * @return The original packet index.
	 */
	public long getOriginalSendingIndex() {
		return originalSendingIndex;
	}

	/**
	 * Retrieve the desired sending order after processing has completed.
	 * <p>
	 * Higher sending order means lower priority.
	 * @return Desired sending order.
	 */
	public long getNewSendingIndex() {
		return newSendingIndex;
	}

	/**
	 * Sets the desired sending order after processing has completed.
	 * <p>
	 * Higher sending order means lower priority.
	 * @param newSendingIndex - new packet send index.
	 */
	public void setNewSendingIndex(long newSendingIndex) {
		this.newSendingIndex = newSendingIndex;
	}

	/**
	 * Retrieve the packet stream responsible for transmitting this packet.
	 * @return The packet stream.
	 */
	public PacketStream getPacketStream() {
		return packetStream;
	}

	/**
	 * Sets the output packet stream responsible for transmitting this packet.
	 * @param packetStream - new output packet stream.
	 */
	public void setPacketStream(PacketStream packetStream) {
		this.packetStream = packetStream;
	}

	/**
	 * Retrieve whether or not this packet has been processed by the async listeners.
	 * @return TRUE if it has been processed, FALSE otherwise.
	 */
	public boolean isProcessed() {
		return processed;
	}

	/**
	 * Sets whether or not this packet has been processed by the async listeners.
	 * @param processed - TRUE if it has, FALSE otherwise.
	 */
	void setProcessed(boolean processed) {
		this.processed = processed;
	}

	/**
	 * Retrieve whether or not this packet has already been sent.
	 * @return TRUE if it has been sent before, FALSE otherwise.
	 */
	public boolean isTransmitted() {
		return transmitted;
	}

	/**
	 * Retrieve iterator for the next listener in line.
	 * @return Next async packet listener iterator.
	 */
	public Iterator<PrioritizedListener<ListenerToken>> getListenerTraversal() {
		return listenerTraversal;
	}
	
	/**
	 * Set the iterator for the next listener.
	 * @param listenerTraversal - the new async packet listener iterator.
	 */
	void setListenerTraversal(Iterator<PrioritizedListener<ListenerToken>> listenerTraversal) {
		this.listenerTraversal = listenerTraversal;
	}
	
	/**
	 * Transmit a given packet to the current packet stream.
	 * @param event - the packet to send.
	 * @throws IOException If the packet couldn't be sent.
	 */
	public void sendPacket(PacketEvent event) throws IOException {
		try {
			if (event.isServerPacket()) {
				packetStream.sendServerPacket(event.getPlayer(), event.getPacket(), false);
			} else {
				packetStream.recieveClientPacket(event.getPlayer(), event.getPacket(), false);
			}
			transmitted = true;
			
		} catch (InvocationTargetException e) {
			throw new IOException("Cannot send packet", e);
		} catch (IllegalAccessException e) {
			throw new IOException("Cannot send packet", e);
		}
	}
	
	@Override
	public int compareTo(AsyncMarker o) {
		if (o == null)
			return 1;
		else
			return Longs.compare(getNewSendingIndex(), o.getNewSendingIndex());
	}
}
