package com.comphenix.protocol.async;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.util.Iterator;

import com.comphenix.protocol.PacketStream;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.injector.PrioritizedListener;
import com.google.common.primitives.Longs;

/**
 * Represents a packet that is being processed by asynchronous listeners.
 * 
 * @author Kristian
 */
public class AsyncPacket implements Serializable, Comparable<AsyncPacket> {
	
	/**
	 * Signal an end to the packet processing.
	 */
	static final AsyncPacket INTERUPT_PACKET = new AsyncPacket();
	
	/**
	 * Generated by Eclipse.
	 */
	private static final long serialVersionUID = -2621498096616187384L;

	/**
	 * Default number of milliseconds until a packet will rejected.
	 */
	public static final int DEFAULT_TIMEOUT_DELTA = 60000;
	
	/**
	 * The original synchronized packet.
	 */
	private PacketEvent packetEvent;
	
	/**
	 * The packet stream responsible for transmitting the packet when it's done processing.
	 */
	private transient PacketStream packetStream;
	
	/**
	 * Current list of async packet listeners.
	 */
	private transient Iterator<PrioritizedListener<ListenerToken>> listenerTraversal;
	
	// Timeout handling
	private long initialTime;
	private long timeout;
	
	// Packet order
	private long originalSendingIndex;
	private long newSendingIndex;
	
	// Whether or not the packet has been processed by the listeners
	private volatile boolean processed;
	
	private AsyncPacket() {
		// Used by the poision pill pattern
	}
	
	/**
	 * Determine whether or not this is a signal for the async listener to interrupt processing.
	 * @return Interrupt packet processing.
	 */
	boolean isInteruptPacket() {
		// This is only possble if we're dealing with the poision pill packet
		return packetEvent == null || packetStream == null;
	}
	
	/**
	 * Create a container for asyncronous packets.
	 * @param packetEvent - the synchronous packet event.
	 * @param initialTime - the current time in milliseconds since 01.01.1970 00:00.
	 */
	public AsyncPacket(PacketStream packetStream, PacketEvent packetEvent, long sendingIndex, long initialTime, long timeoutDelta) {
		if (packetEvent == null)
			throw new IllegalArgumentException("packetEvent cannot be NULL");
		if (packetStream == null)
			throw new IllegalArgumentException("packetStream cannot be NULL");
		
		this.packetStream = packetStream;
		this.packetEvent = packetEvent;
		
		// Timeout
		this.initialTime = initialTime;
		this.timeout = initialTime + timeoutDelta;
		
		// Sending index
		this.originalSendingIndex = sendingIndex;
		this.newSendingIndex = sendingIndex;
	}
	
	/**
	 * Retrieve the time the packet was initially queued for asynchronous processing.
	 * @return The initial time in number of milliseconds since 01.01.1970 00:00. 
	 */
	public long getInitialTime() {
		return initialTime;
	}	

	/**
	 * Retrieve the time the packet will be forcefully rejected.
	 * @return The time to reject the packet, in milliseconds since 01.01.1970 00:00.
	 */
	public long getTimeout() {
		return timeout;
	}
	
	/**
	 * Retrieve the order the packet was originally transmitted.
	 * @return The original packet index.
	 */
	public long getOriginalSendingIndex() {
		return originalSendingIndex;
	}

	/**
	 * Retrieve the desired sending order after processing has completed.
	 * <p>
	 * Higher sending order means lower priority.
	 * @return Desired sending order.
	 */
	public long getNewSendingIndex() {
		return newSendingIndex;
	}

	/**
	 * Sets the desired sending order after processing has completed.
	 * <p>
	 * Higher sending order means lower priority.
	 * @param newSendingIndex - new packet send index.
	 */
	public void setNewSendingIndex(long newSendingIndex) {
		this.newSendingIndex = newSendingIndex;
	}

	/**
	 * Retrieve the original synchronous packet event.
	 * @return The original packet event.
	 */
	public PacketEvent getPacketEvent() {
		return packetEvent;
	}
	
	/**
	 * Retrieve the packet ID of the underlying packet.
	 * @return Packet ID.
	 */
	public int getPacketID() {
		return packetEvent.getPacketID();
	}
	
	/**
	 * Retrieve the packet stream responsible for transmitting this packet.
	 * @return The packet stream.
	 */
	public PacketStream getPacketStream() {
		return packetStream;
	}

	/**
	 * Sets the output packet stream responsible for transmitting this packet.
	 * @param packetStream - new output packet stream.
	 */
	public void setPacketStream(PacketStream packetStream) {
		this.packetStream = packetStream;
	}

	/**
	 * Retrieve whether or not this packet has been processed by the async listeners.
	 * @return TRUE if it has been processed, FALSE otherwise.
	 */
	boolean isProcessed() {
		return processed;
	}

	/**
	 * Sets whether or not this packet has been processed by the async listeners.
	 * @param processed - TRUE if it has, FALSE otherwise.
	 */
	void setProcessed(boolean processed) {
		this.processed = processed;
	}

	/**
	 * Retrieve iterator for the next listener in line.
	 * @return Next async packet listener iterator.
	 */
	Iterator<PrioritizedListener<ListenerToken>> getListenerTraversal() {
		return listenerTraversal;
	}

	/**
	 * We're done processing. Send the packet.
	 */
	void sendPacket() {
		try {
			// We only support server packets at this stage
			packetStream.sendServerPacket(packetEvent.getPlayer(), packetEvent.getPacket(), false);
		} catch (InvocationTargetException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Set the iterator for the next listener.
	 * @param listenerTraversal - the new async packet listener iterator.
	 */
	void setListenerTraversal(Iterator<PrioritizedListener<ListenerToken>> listenerTraversal) {
		this.listenerTraversal = listenerTraversal;
	}

	@Override
	public int compareTo(AsyncPacket o) {
		if (o == null)
			return 1;
		else
			return Longs.compare(getNewSendingIndex(), o.getNewSendingIndex());
	}
}
